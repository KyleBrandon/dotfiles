" Start 'er up!
filetype off
call pathogen#incubate()
call pathogen#helptags()

" call pathogen#helptags()
filetype plugin indent on
syntax on

" Forte
let g:syntastic_java_javac_maven_args="-Dplatform.classifier=overture -Poverture"

" Leader maps
noremap \ ,
let mapleader=","

" Just say no
map <Left> <Nop>
map <Right> <Nop>
map <Up> <Nop>
map <Down> <Nop>

" Internal macros
runtime macros/matchit.vim        " Load the matchit plugin.

" Mercurial Blame
vmap <Leader>b :<C-U>!hg blame -fu <C-R>=expand("%:p") <CR> \| sed -n <C-R>=line("'<") <CR>,<C-R>=line("'>") <CR>p <CR>

" Tern
let g:tern_map_keys=1
let g:tern_show_argument_hints='on_hold'
nmap <Leader>td :TernDoc<cr>
nmap <Leader>tt :TernType<cr>
nmap <Leader>td :TernDef<cr>
nmap <Leader>tR :TernRename<cr>

" Command-T remaps
nmap <leader>o :CommandT<CR>
nmap <leader>O :CommandTFlush<CR>
nmap <leader>m :CommandTBuffer<CR>
let g:CommandTCancelMap = ['<ESC>', '<C-c>']
let g:CommandTMaxHeight=50
let g:CommandTMatchWindowAtTop=0
" Fuzzy finder: ignore stuff that can't be opened, and generated files
let g:fuzzy_ignore = "*.png;*.PNG;*.JPG;*.jpg;*.GIF;*.gif;vendor/**;coverage/**;tmp/**;rdoc/**;target/**"

" CTags remaps
nmap <leader>c :!ctags -R --exclude='.hg'<CR>
nmap <leader>f <C-]>
nmap <leader>r <C-t>

" Dash
:nmap <silent> <leader>d <Plug>DashSearch

" Map tab to indent in visual mode
vmap <tab> >gv
vmap <s-tab> <gv
vmap > >gv
vmap < <gv

imap <tab> <c-r>=InsertTabWrapper()<cr>
imap <s-tab> <c-p>

" Cut-n-Paste
nmap <Leader>p "0p
nmap <Leader>P "0P
nmap <Leader>y "0y
nmap <Leader>Y "0Y
nmap <leader>v V`]


" Edit another file in the same directory as the current file
" uses expression to extract path from current file's path
cmap %% <C-R>=expand('%:h').'/'<cr>
nmap <Leader>e :e %%
nmap <Leader>es :sp %%
nmap <Leader>ev :vsp %%

nmap <Leader>ve :e ~/.vimrc<CR>
nmap <Leader>te :e ~/.tmux.conf<CR>

" Fix search
nmap / /\v
vmap / /\v
nmap <Leader>h :nohl<cr>
nmap <leader>a :Ack
set showmatch
set incsearch                     " Highlight matches as you type.
set hlsearch                      " Highlight matches.
set ignorecase                    " Case-insensitive searching.
set smartcase                     " But case-sensitive if expression contains a capital letter.

" Add * and # support to search for current selection
xnoremap * :<C-u>call <SID>VSetSearch()<CR>/<C-R>=@/<CR><CR>
xnoremap # :<C-u>call <SID>VSetSearch()<CR>?<C-R>=@/<CR><CR>

" Show invisibles
set list
set listchars=tab:▸\ ,eol:¬
highlight NonText guifg=#4a4a59

" Splits
set splitbelow
set splitright

nmap <C-j> <C-w>j
nmap <C-k> <C-w>k
nmap <C-h> <C-w>h
nmap <C-l> <C-w>l

nmap <Leader>s :split<CR>            " New horizontal split on current file
nmap <Leader>v :vsplit<CR>           " New vertical split on current file
nmap <Leader>k :only<CR>                 " Make current split the only one

" Buffers
nmap <Leader><Leader> <C-^>          " Switch to previous buffer

"Color scheme
syntax enable
set background=dark
colorscheme solarized
set colorcolumn=120

nmap ; :
imap <leader>u <esc>viwUea
nmap <leader>u :call Preserve("normal viwU")<cr>

" Default settings
set nocompatible
set backspace=indent,eol,start      " Intuitive backspacing.
set history=1000
set ruler                           " Show cursor position.
set showcmd                         " Display incomplete commands.
set autoindent                      "
set nowrap
set backupdir=~/.tmp
set directory=~/.tmp                " Don't clutter my dirs up with swp and tmp files
set autoread
set laststatus=2
set showmode                      " Display the mode you're in.
set hidden                        " Handle multiple buffers better.
set wildmenu                      " Enhanced command line completion.
set wildmode=list:longest         " Complete files like a shell.
set wildignore+=*.class,.git,.hg,*/target/*
set number                        " Show line numbers.
set title                         " Set the terminal's title
set visualbell                    " No beeping.
set nobackup                        " Don't make a backup before overwriting a file.
set nowritebackup                   " And again.
set cursorline

set tabstop=8
set shiftwidth=4
set softtabstop=4
set expandtab
set shiftround

" (Hopefully) removes the delay when hitting esc in insert mode
set noesckeys
set timeout timeoutlen=500 ttimeoutlen=1


" Run a command saving the last search and curosr position.
function! Preserve(command)
    " Preparation: save last search, and cursor position.
    let _s=@/
    let l = line(".")
    let c = col(".")
    " Do the business:
    execute a:command
    " Clean up: restore previous search history, and cursor position
    let @/=_s
    call cursor(l, c)
endfunction

" Bind _$ to remove whitespace
nmap _$ :call Preserve("%s/\\s\\+$//e")<CR>

" Bind _= to re-indent the buffer
nmap _= :call Preserve("normal gg=G")<CR>


" Only do this part when compiled with support for autocommands
if has("autocmd")
    " Enable file type detection
    filetype on

    " Syntax of these languages is fussy over tabs Vs spaces
    autocmd FileType make setlocal ts=8 sts=8 sw=8 noexpandtab

    " Customisations based on house-style (arbitrary)
    autocmd FileType xml setlocal ts=4 sts=4 sw=4 expandtab
    autocmd FileType html setlocal ts=2 sts=2 sw=2 expandtab
    autocmd FileType css setlocal ts=2 sts=2 sw=2 expandtab
    autocmd FileType javascript setlocal ts=2 sts=2 sw=2 expandtab
    autocmd FileType java setlocal ts=4 sts=4 sw=4 expandtab

    " Treat .rss files as XML
    autocmd BufNewFile,BufRead *.rss setfiletype xml
    "
    " Remove trailing space automatically on java and javascript files on save
    autocmd BufWritePre *.java,*.js,*.xml,*.properties :call Preserve("%s/\\s\\+$//e")

    autocmd FileType java :DashKeywords="javaee6 java6"
    autocmd FileType javascript :DashKeywords="javascript underscrore backbone jquery"

    autocmd BufRead,BufNewFile *.md set filetype=markdown
    autocmd BufRead,BufNewFile *.md setlocal spell
    autocmd BufRead,BufNewFile *.md setlocal textwidth=80

    autocmd FocusLost * :wa
endif


function! s:VSetSearch()
    let temp = @s
    norm! gv"sy
    let @/ = '\V' . substitute(escape(@s, '/\'), '\n', '\\n', 'g')
    let @s = temp
endfunction

function! InsertTabWrapper()
    let col = col(".") - 1
    if !col || getline(".")[col - 1] !~ '\k'
        return "\<tab>"
    else
        return "\<c-n>"
endfunction


